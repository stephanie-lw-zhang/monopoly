##High-Level Design Goals


The main goal of our project was to create a generalized, data-driven game application that supports the original game of Monopoly, as well as custom types / other variations of Monopoly, without needing to create new high level classes in our project structure. All users would need to do to implement “house rules” or some variation of Monopoly is create the correct XML data files.

We achieve this goal by keeping all code abstracted (e.g. AbstractBoardView, AbstractPropertyTile, AbstractPlayer, etc.) and data-driven. Everything begins at the engine. MonopolyDriver class, but after that, all user interaction dictates the direction of the game. We employed an MVC framework for our application as the main design structure, and also utilized reflection to complement our data-driven inputs and to eliminate all “hard-coding” of initialization of variables/parameters.

Essentially, GameSetUpController and GameController ties together all classes located in the packages backend and frontend with GameSetUp being responsible for all things pre-game (configuration, data-reading, initializing of Backend components, initializing GameController) and GameController being responsible for all things during-game (updating Views of the board, dice, players icons, etc.). These two classes remove all dependencies between backend and frontend classes, touching on the principles of encapsulation and the idea of a “black box” in which inputs/outputs/functionality are known about a class but the internal workings will be hidden from classes. For example, GameController will know that two rolled dice returns a desired integer representing the sum of the two dice. It will not know how the integer is given, but it simply passes that integer along to the frontend to be displayed. Furthermore, there are more specific “sub-controllers” related to the game logic such as Turn, ActionCardController, PassedTileActionController, and TileActionController. Additionally, it should be noted that GameSetUpController and GameController read in mostly abstract backend classes and abstract frontend classes, thus keeping functionality flexible and modular. For instance, specific dependencies on certain classes in the backend are not required, but rather, any type of custom subclasses of some abstract class is all the controller(s) need to know.

On game start, GameSetUpController creates the data-driven AbstractBoard, after reading in all player registrations from the frontend FormView component containing information such as player name, player icon, and player type (Human/AI). This AbstractBoard is then used to initialize a GameController, which takes on the controlling for the actual game. At this time, a AbstractGameView is initialized set as the main View component on the AbstractScreen. AbstractGameView represents the overarching View seen on start of Game. We employ a SplitScreenView (a type of AbstractGameView), that is a 50/50 split of the Screen. The left node of the SplitScreenView contains a SquareBoardView (AbstractBoardView) which contains TileViews and IconViews (player icon pieces). The right node of the SplitScreenView contains a BPaneOptionsView (AbstractOptionsView) that contains all user controls (buttons, cheat keys, etc.) as well as player statistics (funds, properties owned, etc.) which are contained in abstract StatsViews.

In terms of the backend, there is not much of a hierarchy or relationship between classes, as there should not be. Each backend class contains its own logic and functionality independent of other backend classes. This made sense to us as the backend classes were the “models” of the project that simply performed their tasks with no understanding of the game state or other model classes. The board (AbstractBoard) was designed to store the most information, with main references to a list of AbstractPlayers, an adjacency map of AbstractTiles, number of die, and a Bank. Note, Bank and AbstractPlayer both extend an AbstractAssetHolder as they share much of the same functionality of holding funds and properties (the main “assets” in Monopoly). Broad Tile types were summarized as AbstractDrawCardTile, AbstractNonBuildingPropertyTile, AbstractPropertyTile, and AbstractTaxTile. Each specific type of Tile then extended one of these classes. Lastly, the die are also some AbstractDice to provide for multiple types of dice implementations.

For the frontend, there is a general hierarchy as mentioned above.  GameViews tend to manage BoardViews and OptionsViews.  There is further organization present down the chain with BoardViews managing TileViews and OptionsViews managing all the views for game displays.  The front-end itself does not contain much independent logic of its own; most of the methods present in the front-end are based on expected requests from controller.  For example, the createButtons method takes in a Map of Strings and EventHandlers, which allows the relevant buttons to be created and handled.  However, in the process of this creation the View truly is only responsible for displaying the buttons somewhere; the contents of the EventHandlers are not visible to the view.  The frontend display is also based entirely off of the back-end for layout and moving; layout is based off of tileindices, and moving is based on linking tiles to tileviews and moving based on the tile that is passed in as a parameter.  Top-level classes like GameView and FormView are managed by Controllers, which work together with Screens to display the views.  Screens are View-based in their purpose but due to their composition of Controllers they do exhibit some controller-centric behavior.


##How to Add New Features


Add new game: Change the variable named CONFIG_STRING in the GameSetUpController class to the name of the xml file you read in the new game from. Create a new xml file according to the specifics of your game. This includes, the tiles (name, type, color, buildings that can be built on it, rent prices, mortgage price, etc), decks and cards, number of dice, amount of money each player starts with, etc. 
Add a new type of action card: Create a new class that extends the abstract ActionCard class. Since we use reflection to call the appropriate method to actually apply the action card’s action, you must also create a method named “handle” + type in ActionCardController. However, any pay cards must also be reinitialized with a method called “reinitialize” + type in TileActionController. This is because we do not know the players in the game until the game is started, and we do not know which player will draw which card either. Thus, upon initialization of the game we cannot immediately determine the “payers” and “payees.” At the moment the current types of action cards are Move, MoveAndPay, Pay, PayBuildings, and GetOutOfJail. In the XML file, each action card should have a “Card Type” tag and a “Type” tag, which both indicate the type of card that is being made, followed by tags for the information needed for each card (ex. For MoveAndPay cards, we need the “Payer,” “Payee,” “Multiplier,” and “TargetTileType”). Finally, all cards need a “Message” tag indicating what should be displayed on the card.
EXAMPLE: 
<ActionCard>
   <CardType>MoveAndPayCard</CardType>
   <Type>MoveAndPay</Type>
   <Payer>CurrentPlayer</Payer>
   <Payee>Owner</Payee>
   <Multiplier>2</Multiplier>
   <TargetTileType>RailroadTile</TargetTileType>
   <Message>Advance to Nearest Railroad and Pay Double if Owned</Message>
</ActionCard>

Add a new type of holdable card: Create a new class that extends the abstract HoldableCard class. Since we use reflection to call the appropriate method to actually apply the holdable card’s action, you must also create a method named “handle” + getHoldableCardAction in ActionCardController. In the XML file, we need the tags “CardType” and “Type” to indicate the type of card that is being made. Additionally, we need a “Message” tag indicating what should be displayed on the card.
Add a new type of tile: Create a new class that extends the appropriate abstract class (for example. AbstractPropertyTile). The applyLandedOnAction method must return a list of strings of possible actions that are a result of landing on a tile. Since we use reflection to call the appropriate method to actually apply (or allow users to choose) these possible actions, you must also create a method named “handle” + name of each possible action (AKA each string in the list) in TileActionController. In the XML file, all tiles are prefaced with the tag “Tile,” followed by the tags “TileNumber,” which indicates the tile’s index on the board, “TileType,” which indicates the type of tile being made, and “NextTiles,” which indicates each tile’s neighbors. Then, depending on the tile, there could be several other different tags following these 3 main ones. For example, the GO tile requires “TileColor,” “LandedMoney,” and “PassedMoney” tags, while Building Tiles require an associate “Card” tag within the “Tile” tag, so that each card can be associated with its corresponding building.
Add a new type of deck: Create a new class that implements DeckInterface. The drawCard method should draw the card from the deck in whichever way the game asks the card to be drawn (from the top, from the bottom, etc.). The putBack method should put the card back in whichever way the game asks the card to be put back (randomly, on the top, etc.). The addCards method adds cards to the deck in whichever way the game asks for them to be added, and the getName method should return the overall name of the deck (in Original Monopoly, it was either Chance or Community Chest). Finally, after all of these methods have been implemented, the deck can be initialized in the board after being read in from the XML data file. It is important to note that the indicator for a deck to be read in in the XML file is the tag “Deck”, and within this tag, we want to first indicate the name of the deck with the tag “Name” and then the cards needed, which is indicated with the tag “ActionCard.”
Add a new type of gamelayout: create another instance of abstractgameview and implement all the corresponding methods.  AbstractGameView itself is responsible for arranging the different views of the game and act as a waypoint between the controller and the view.  In effect, it is the top-level view class that the controller communicates with whenever an action or information is needed.  Exact implementation can vary widely; there can be multiple screens for example, and the exact layout of the views is up to user discretion.  The presence of the abstract methods, however, ensure that the proper functionality and information can be supported by this new game layout
Add a board with a new board shape: implement a new instance of the abstractboardview class.  This specifically requires the implementation of the makeboard method, which is meant to be the method from which the entire board is laid out. exact implementation is again left up to the user, but if each method required by the AbstractBoardView class is implemented then the new board shape should be implemented properly.


##Justifying Major Design Choices, Including Trade-offs (i.e., pros and cons)


We used AbstractScreens as a design choice for the medium on which Views would be placed. The pros of our screen structure is that it keeps each rendered scene single-purpose. We don’t just share one Scene object throughout the game, as we feel it makes more sense -- and is more generalizable -- to have a single MainMenuScreen at the start of the game, then depending on user interactions, new Screens are redirected to.  However, the nature of how we wrote screens makes them also function as controllers, since the screens have to pass themselves over to the controllers so that the controllers have access to changing the screens or changing the node that is displayed.   Since the screen class is still relatively small, though, we saw it as an acceptable tradeoff for the flexibility of functionality that it enabled.
We used encapsulation throughout our project - view and controller were both structured in a hierarchical manner.  When logic was not directly handled by a class it would be delegated to a lower-level class to finish.  This increased the number of methods by a significant margin because propagating methods from one lower-level class to another lower-level class now takes much more calls than if there was direct communication available.  However, we took this tradeoff knowing that these hierarchy levels kept classes small and single-purpose while ensuring that the guts of each segment would not be overexposed.
We chose in our MVC model to keep the view mostly dumb and concentrate the logic in the controller classes.  This kept our classes compact and their functionality clear. This meant that the logic was all located in the controller classes.  Although the controller classes had a propensity to grow long simply because all of the handler methods that we wrote for each action, it was good that they were consistently handled by the controllers.  Furthermore, the hierarchical structure in the controller classes meant that we were able to keep the flow of events relatively clean.
In the front-end, we chose to implement the views based on composition instead of inheritance.  This gave us the power to limit the amount of access that other classes had to the specific javafx object.  This also had the benefit of leaving our code more flexible, as we mostly cared about how the view objects interacted with each other and not about what the actual view objects were.  This meant that we could have many different ways of implementing the same thing; if inheritance was used it would be much more inflexible because you can only extend one class.
We decided to use XML files to configure data rather than CSV or properties files. Our reasoning was that XML files are more flexible in that different amounts of nodes and tag values could be used. A nodelist could be initialized and looped through so that the number of tiles or action cards (for example) could be variable. This would have been possible with CSV or properties files, but it would have taken more logic and time than simply initializing a nodelist with one line of code. We also opted to put almost all of the data to initialize a game (besides things input by the user such as the names and number of players) in one file. This lead to files being almost 1500 lines long. This decision would make it difficult to create and edit these files because of their length. If we had broken it up into several different files, it might have been easier and clearer to make small changes.
In our second demo we had stated that we would use Enumerations for the actions that could occur throughout the game, that being either actions that could occur after a tile has been landed on or actions that can be done anytime. The pros of this were that in each game, there are a standard number of actions, so the number and types of Enum actions should stay fixed for one game. However, we would have had to create several new controllers in order to implement different types games. Additionally, we had a long case statement to deal with what to do in the case of each Enum, which was not flexible enough for new actions, if we had forgotten any, to be easily added. Thus, we decided to instead use reflection to handle tile landings. 

```java
public void handleTileLanding(Tile tile) {
   try {
       List<String> actions = tile.applyLandedOnAction( myTurn.getMyCurrPlayer() );
       if (actions.size() != 0) {
           String desiredAction = determineDesiredActionForReflection(actions);
           TileActionController tileActionController = new TileActionController(myBoard, myTurn, myGameView, this);
           Method handle = tileActionController.getClass().getMethod("handle" + desiredAction);
           handle.invoke(tileActionController);
       }
   } catch (NoSuchMethodException e) {
       myGameView.displayActionInfo("There is no such method");
   } catch (SecurityException e) {
       myGameView.displayActionInfo("Security exception");
   } catch (IllegalAccessException e) {
       myGameView.displayActionInfo("Illegal access exception");
   } catch (IllegalArgumentException e) {
       myGameView.displayActionInfo("Illegal argument");
   } catch (InvocationTargetException e) {
       myGameView.displayActionInfo("Invocation target exception");
       e.printStackTrace();
   }
}
```

This way, we could easily add a new method in one of the controllers to account for a new type of action. Additionally, this made our code more generalizable so that we could use the same four main controllers (GameController, TileActionController, PassedTileActionController, and ActionCardController) for different game implementations.


##Assumptions or Decisions Made to Simplify/Resolve Ambiguities


We assume that the bank has unlimited money.
In terms of Views, we assume dice can be any N-Die less than 7 states (backend certainly supports any N number of dice states, but the frontend does not) - but this is 
We assume that once a player is sent to jail, they cannot use the Get out of Jail Free card until the BEGINNING of their next turn. If they choose to roll instead, then they are not permitted to use the Get out of Jail Free card for the rest of that turn.
We assume that we have written all possible handlers for player options/controls for the games created thus far. However, if a user wanted to add a custom action, they would need to create a new method.
We assume all new data files that are going to be created will follow the same XML structure that we have laid out. For example, we expect each XML file to have a corresponding csv for board layout, and will have the correct tags and corresponding values that are needed for each game.
